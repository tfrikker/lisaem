/**************************************************************************************\
*                                                                                      *
*              The Lisa Emulator Project  V1.2.7      RC5 2022.07.04                   *
*                             http://lisaem.sunder.net                                 *
*                                                                                      *
*                  Copyright (C) 1998, 2022 Ray A. Arachelian                          *
*                                All Rights Reserved                                   *
*                                                                                      *
*           This program is free software; you can redistribute it and/or              *
*           modify it under the terms of the GNU General Public License                *
*           as published by the Free Software Foundation; either version 3             *
*           of the License, or (at your option) any later version.                     *
*                                                                                      *
*           This program is distributed in the hope that it will be useful,            *
*           but WITHOUT ANY WARRANTY; without even the implied warranty of             *
*           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
*           GNU General Public License for more details.                               *
*                                                                                      *
*           You should have received a copy of the GNU General Public License          *
*           along with this program;  if not, write to the Free Software               *
*           Foundation, Inc., 59 Temple Place #330, Boston, MA 02111-1307, USA.        *
*                                                                                      *
*                   or visit: http://www.gnu.org/licenses/gpl.html                     *
*                                                                                      *
\**************************************************************************************/


// -- protos --------------------------------------------------------------------------
// soundid is the enum below.
int             IsSoundPlaying(int soundid);
int             IsSoundLoaded(int soundid);
void            StopSound(int soundid);
void            PlaySound(int soundid);
void            InitSounds(wxString skindir, LisaSkin skin);
extern "C" void sound_play(uint16 t2, uint8 SR, uint8 floppy_iorom); // called from via6522.c
extern "C" void sound_off(void); // called from via6522.c


wxSound *sounds[MAX_WAV_SOUNDS];

float normalthrottle=0;

//wxSound          *my_lisa_sound=NULL;       // sounds generated by Lisa Speaker


int IsSoundLoaded(int soundid) {
  if         (sounds[soundid]!=NULL)
     return   sounds[soundid]->IsOk();
  else return false;
}


int IsSoundPlaying(int soundid) {
  if         (sounds[soundid]!=NULL)
       return sounds[soundid]->IsPlaying();
  else return false;
}

void StopSound(int soundid) {
  if   (      sounds[soundid]!=NULL)
      if  (   sounds[soundid]->IsPlaying())
              sounds[soundid]->Stop();
}

void PlaySound(int soundid, int async) {
  if       (  sounds[soundid]!=NULL)
      if    (!sounds[soundid]->IsPlaying())
        if  (!sounds[soundid]->IsOk())
              sounds[soundid]->Play( ((async & 1) ? wxSOUND_ASYNC:wxSOUND_SYNC) | ((async & 2) ? wxSOUND_LOOP:0) );
}

// Inside LisaEmApp::OnInit:2970    
void  InitSounds(wxString skindir, LisaSkin *skin) {
      wxString sndfile;

      sounds[snd_floppy_eject]          = NULL;
      sounds[snd_floppy_insert]         = NULL;
      sounds[snd_floppy_insert_nopower] = NULL;
      sounds[snd_floppy_motor1]         = NULL;
      sounds[snd_floppy_motor2]         = NULL;
      sounds[snd_lisa_power_switch01]   = NULL;
      sounds[snd_lisa_power_switch02]   = NULL;
      sounds[snd_poweroffclk]           = NULL;

      ALERT_LOG(0,"Loading sounds");

      sndfile=skindir + skin->floppy_eject;           sounds[snd_floppy_eject]          = new wxSound(sndfile); // 0
      sndfile=skindir + skin->floppy_insert;          sounds[snd_floppy_insert]         = new wxSound(sndfile); // 1
      sndfile=skindir + skin->floppy_insert_nopower;  sounds[snd_floppy_insert_nopower] = new wxSound(sndfile); // 2
      sndfile=skindir + skin->floppy_motor1;          sounds[snd_floppy_motor1]         = new wxSound(sndfile); // 3
      sndfile=skindir + skin->floppy_motor2;          sounds[snd_floppy_motor2]         = new wxSound(sndfile); // 4
      sndfile=skindir + skin->lisa_power_switch01;    sounds[snd_lisa_power_switch01]   = new wxSound(sndfile); // 5
      sndfile=skindir + skin->lisa_power_switch02;    sounds[snd_lisa_power_switch02]   = new wxSound(sndfile); // 6
      sndfile=skindir + skin->poweroffclk;            sounds[snd_poweroffclk]           = new wxSound(sndfile); // 7
}

void DestroySounds(void) {

}

wxSound my_lisa_sound;
// this crashes on macosx   if (!!my_lisa_sound) delete my_lisa_sound;
// my_lisa_sound=new wxSound;  //my_lisa_sound->Create(dataptr,data_size);


extern "C" void sound_off(void)
{
    // restore throttle
    if (normalthrottle!=0)
    {my_lisaframe->throttle=normalthrottle; update_menu_checkmarks(); }// updateThrottleMenus(my_lisaframe->throttle);}

    if (cpu68k_clocks-my_lisaframe->lastclk<50000) return;  // prevent sound from shutting down immediately
    if (my_lisa_sound.IsPlaying() ) {
        ALERT_LOG(0,"Stopping sound due to change of VIA1 ACR1");
        my_lisa_sound.Stop();
      //wxSound::Stop();
    }
}

extern "C" void sound_play(uint16 t2, uint8 SR, uint8 floppy_iorom)
{

    // temporarily slow down CPU durring beeps so that they're fully played.
    normalthrottle=my_lisaframe->throttle; update_menu_checkmarks(); //updateThrottleMenus(5.0);
    // 0x2D22=11554 Hz   11Khz
    // 0x5622=22050 Hz   22Khz
    // 0xAC44=44100 Hz   44Khz
    #define RATE (11554)
    int samples=RATE*2*10*8;  // size of WAV to create

    int data_size=0, cycles, eighthcycles;
    uint8 vhigh, vlow;

    if (t2>0xaf) {ALERT_LOG(0,"T2 out of range:       0x%02x",t2); return;}                       // out of range

    if (my_lisaframe->lastt2==t2 && (cpu68k_clocks-my_lisaframe->lastclk < 50000)) 
                 {ALERT_LOG(0,"repeat call suppressed 0x%02x",t2); return;}                       // duplicate call if timing <1/100th of a second

    my_lisaframe->lastt2=t2;
    my_lisaframe->lastclk=cpu68k_clocks;

#ifdef DEBUG
    if ((floppy_iorom & 0xa0)==0xa0) {    // check for A8 IOROM
      if      (t2== ((0x20 >>2) + 0x20) ) {ALERT_LOG(0,"HIPTCH 0x28 Lisa 2/5 A8 ROM");}
      else if (t2== ((0x60 >>2) + 0x60) ) {ALERT_LOG(0,"LOPTCH 0x78 Lisa 2/5 A8 ROM");}
      else if (t2== ((0xa0 >>2) + 0xa0) ) {ALERT_LOG(0,"CLICK  0xc8 Lisa 2/5 A8 ROM");}
      else                                {ALERT_LOG(0,"Other sound freq: %02x for Lisa 2/5 A8 ROM (28=high, 78=low)",t2);}
    }
    else
    {
      if      (t2==(0x20))                {ALERT_LOG(0,"HIPTCH 0x20 Lisa 2/10 88 ROM");}
      else if (t2==(0x60))                {ALERT_LOG(0,"LOPTCH 0x60 Lisa 2/10 88 ROM");}
      else if (t2==(0xa0))                {ALERT_LOG(0,"CLICK  0xa0 Lisa 2/10 88 ROM");}
      else                                {ALERT_LOG(0,"Other sound freq: %02x for Lisa 2/10 88 ROM (20=high, 60=low)",t2);}
    }
#endif

    static const unsigned char header[45]=
    {
            //   0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
      /*00*/  0x52,0x49,0x46,0x46,0x00,0x00,0x00,0x00,0x57,0x41,0x56,0x45,0x66,0x6D,0x74,0x20,  // RIFFF-..WAVEfmt
      /*10*/  0x10,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x22,0x56,0x00,0x00,0x22,0x56,0x00,0x00,  //  ........"V.."V..
      /*20*/  0x01,0x00,0x08,0x00,0x64,0x61,0x74,0x61,0x22,0x2D,0x00,0x00//0x80,0x80,0x80,0x80  //  ....data"-......
    };       //                      d    a    t    a [LSB____________MSB]

    static unsigned char data[RATE*2*10*8  +45+1024];
    unsigned char *dataptr;
    //data=(unsigned char *)calloc(1,45+samples+1024);  // allocate a buffer, make it 22Kbps
    memcpy(data,header,45);        // copy the header over it.

// ac44 2022 5622 15888
    data[0x16]=1;      // 1=1 channel = mono, 2= 2 channels = stereo
    data[0x17]=0;

    // *** this works from RAM now but the pitch  is way too high, so had to switch to 44KHz
    data[0x18]=RATE>>8;       // bit rate LSB.   0x5622=22050Hz   22Khz
    data[0x19]=RATE & 0xff;   //                 0x2D22=11554Hz   11Khz
    data[0x1a]=0x00;          //                 0xAC44=44100Hz   44Khz was this <<--
    data[0x1b]=0x00;          // bit rate MSB

    data[0x1c]=data[0x18];    // bytes per second
    data[0x1d]=data[0x19];    // should match bit rate above for 8 bit samples
    data[0x1e]=data[0x1a]; 
    data[0x1f]=data[0x1b]; 

    data[0x20]=1;             // Bytes Per Sample:
    data[0x21]=0;             // 1=8 bit Mono, 2=8 bit Stereo or 16 bit Mono, 4=16 bit Stereo

    data[0x22]=8;             // 8, or 16  bits/sample
    data[0x23]=0;

    dataptr=&data[0x2c]; data_size=0;

    volume=(volume & 0x0f);

    // 128 is our 0V, vhigh is the +V, vlow=-V, thus creating a square wave at the selected volume
    vlow =128-(volume<<3);
    vhigh=128+(volume<<3);

    // *** this works from RAM now, but the pitch  is way too high, *4 is to compensate for that.
    cycles=t2;
    if (!(my_lisaconfig->iorom & 0x20)) cycles=cycles*8/10;       // cycles *=0.8
    cycles=(cycles>>1)+(cycles>>2);                               // cycles *=0.75; (1/2 + 1/4th)
    eighthcycles=cycles>>3;                                       // since we use SR's context eightcycles /=8;

    if (eighthcycles<1) eighthcycles=1;                           // high frequency can set this to zero, need at least 1

    long i=0;
    if (t2>0x90) samples=cycles;                                  // prevent click from turning into beep

    while (samples>=cycles)
    {
        int val=(via[1].via[SHIFTREG] & (1<<(i&7))  ) ? vhigh:vlow; 
        i++;
        memset(dataptr,val,eighthcycles); dataptr+=eighthcycles;
        samples-=cycles; data_size+=8;
    }

    ALERT_LOG(0,"samples:%d cycles:%d sizeof(data)=%d",samples,cycles,RATE+45+1024);

    data[0x28]=((data_size)    ) & 0xff;
    data[0x29]=((data_size)>>8 ) & 0xff;
    data[0x2a]=((data_size)>>16) & 0xff;
    data[0x2b]=((data_size)>>24) & 0xff;

    data[0x04]=((data_size+36)    ) & 0xff;
    data[0x05]=((data_size+36)>>8 ) & 0xff;
    data[0x06]=((data_size+36)>>16) & 0xff;
    data[0x07]=((data_size+36)>>24) & 0xff;

    dataptr=&data[0];

    // this should work, but it doesn't on all platforms
    //my_lisa_sound->Create(data_size,dataptr);
    //my_lisa_sound->Play(wxSOUND_ASYNC);
#ifdef __WXOSX__
#define RETARDED_SOUND_PLAY 1
#endif

#ifdef RETARDED_SOUND_PLAY
    // so instead, use the super lame ass way to play a sound
    ALERT_LOG(0,"playing through tmpfile");
    FILE *f;
    f=fopen("tmpsnd.wav","wb");
    if (f) {
              fwrite(dataptr,data_size+45,1,f); fclose(f);
              my_lisa_sound.Create(_T("tmpsnd.wav"),false);
              // we do not check for sound_effects_on here as this is the Lisa beeping.
              ALERT_LOG(0,"Playing sound T2=%d (0x%02x)\n\n\n",t2,t2);
              my_lisa_sound.Play(wxSOUND_ASYNC|wxSOUND_LOOP);
              unlink("tmpsnd.wav");
              my_lisaframe->soundplaying=4;

            }
    errno=0;  // avoid interfearance with other stuff like libdc42.

#else
    // Looks like wxWidgets 3.x added an in memory playback option, so at least it's not as retarded anymore
    // issues with Ubuntu 22.04 + transition to pipewire broke osspd loop playback, if enabled it causes a deadlock
    my_lisa_sound.Create(data_size+45,dataptr);
    if (!my_lisa_sound.IsOk() ) {ALERT_LOG(0,"Failed to create proper sound resource t2=%d",t2); return;}
    ALERT_LOG(0,"Playing sound T2=%d (0x%02x) SR: %02x: %d%d%d%d%d%d%d%d 1/8th cycles:%d \n\n\n",t2,t2,via[1].via[SHIFTREG],
                (via[1].via[SHIFTREG] & 128 ? 1:0),
                (via[1].via[SHIFTREG] &  64 ? 1:0),
                (via[1].via[SHIFTREG] &  32 ? 1:0),
                (via[1].via[SHIFTREG] &  16 ? 1:0),
                (via[1].via[SHIFTREG] &   8 ? 1:0),
                (via[1].via[SHIFTREG] &   4 ? 1:0),
                (via[1].via[SHIFTREG] &   2 ? 1:0),
                (via[1].via[SHIFTREG] &   1 ? 1:0),
                eighthcycles
    );
  //my_lisa_sound.Play(wxSOUND_ASYNC|wxSOUND_LOOP);
    my_lisa_sound.Play(wxSOUND_ASYNC);
    my_lisaframe->soundplaying=4;

#endif

return;
}
